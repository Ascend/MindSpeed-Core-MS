## 分布式调试使用说明

本说明介绍如何在分布式训练环境中使用调试断点功能，实现指定进程进入pdb交互调试，其它进程等待调试完成后再继续执行。

### 使用示例

以下例子展示如何在分布式场景调用断点调试接口。

1. **在模型启动脚本（例如 `pretrain_xxx.sh`）中加入调试设置**

   在执行 `msrun pretrain_gpt.py` 之前，加入以下两行命令：

   ```bash
   #添加如下两行
   source tools/debug_utils/dist_debug.sh
   exit
   ```

   若为pytorch后端， 则在`torch.distributed.launch pretrain_gpt.py` 之前 加入以下两行命令：

   ```bash
    #添加如下两行
    source tools/debug_utils/dist_debug_pt.sh
    exit
    ```

   这样可以在启动前加载调试配置，并暂停正常流程，等待调试过程完成。

2. **修改启动参数**
    在dist_debug.sh/dist_debug_pt.sh中修改 `run_pretrain` 函数内的启动py脚本与入参为原启动脚本内容。
    例如：

    ```bash
        python pretrain_gpt.py \
        $GPT_ARGS \
        $DATA_ARGS \
        $OUTPUT_ARGS \
        $MLA_ARGS \
        $ROPE_ARGS \
        $MOE_ARGS \
        --distributed-backend nccl \
        --ai-framework mindspore
    ```

3. **在代码中添加调试断点**

   在python代码希望调试的地方增加如下两行：

   ```python
   from pdb_utils import breakpoint_, clear_
   breakpoint_()
   ```

   **注意：如果是该行代码往下走会稳定报错的场景，可以使用**

   ```python
   breakpoint_(False)
   ```

   使得其他进程在对应位置停住，从而防止其他rank运行到报错位置导致scheduler杀死集群。

4. **进入调试**
   正常启动pretrain_xxx.sh脚本，等待到达断点处。看见类似如下交互日志时，表明已进入断点调试模式：

   ```bash
   [1744769595.8194475]counter_file created: /tmp/debug_counter_0.txt
   --Return--
   > xxx/MindSpeed-Core-MS/MindSpeed-LLM/pdb_utils.py(26)breakpoint_()->None
   -> pdb.set_trace()
   (Pdb)
   ```

   **注意：此处调试完成后，若使用的`breakpoint_(False)`, 则需额外调用调用 clear_() 解除其它进程的阻塞**

   ```python
   clear_()
   ```

### 常见使用场景：

   场景1) 代码core dump，无法知晓错误栈场景：

   选取一定还未到core dump处的代码，添加断点。
   结合使用`n`、`s`、`c`等命令，逐行调试，执行可疑代码块，查看变量值，找到问题。

   场景2) 代码报错，需打印多处变量定位根因场景：

   选取报错前的代码，添加断点，查看相关变量值，找到问题根因。

   场景3) 精度问题，复现条件复杂，需打印多处变量、多轮添加打印才可定位场景：

   运行用例打印精度未对齐的变量的哈希值（md5），将其存下来，再在对应位置添加if条件。

   **建议：若为精度对齐场景，可创造<=4卡的用例，结合np.save/np.load等接口读写数据，在单机pdb交互式窗口下完成精度比较，定位精度差异来源。

### pdb调试常用命令

pdb常用指令：

   `n(next)` : 执行下一行代码，跳过函数调用。

   `s(step)` : 进入函数内部，逐行调试。

   `w(where)` : 显示当前执行的代码行和调用栈。

   `b(break)` : 设置断点。例如：`b xxx/MindSpeed-LLM/mindspeed_llm/mindspore/core/tensor_parallel/cross_entropy.py:30` 其中xxx为个人路径

   `l(list)` : 显示当前代码的部分上下文。

   `ll(list long)` : 显示当前代码的全部上下文。

   `c(continue)` : 继续执行代码，直到下一个断点。

   `u(up)` : 返回上一层调用栈。

   `r(return)` : 执行到当前函数的返回语句。

   `p(print)` : 打印变量的值。例如：`p loss`。

详细命令可官方参考文档：[python pdb官方链接](https://docs.python.org/3/library/pdb.html#pdbcommand-help)

### 原理实现说明

1. **msrun分布式命令**
   msrun命令本质上为动态组网的封装，在master节点上启动一个scheduler(调度器)进程，负责管理所有worker进程的创建和通信；

   在所有节点上启动若干个worker进程，负责执行训练任务。可参考[msrun实现源码](https://gitee.com/mindspore/mindspore/blob/master/mindspore/python/mindspore/parallel/cluster/process_entity/_api.py#L47)

   以Atlas 800TA2单机8卡任务为例，msrun命令会在每个节点上启动一个scheduler(调度器)进程和8个worker进程，默认状态下，所有worker进程均在后台执行。

   因pdb调试要求交互式调试的进程处于前台运行状态，因此需要设置环境变量指定调试进程的rank使其对应的进程在前台执行，而其他rank进程正常后台执行。

   注：若为`torch.distributed.launch`, 其本质上也是动态组网的封装，可参考[torchrun实现源码](https://github.com/pytorch/pytorch/blob/main/torch/distributed/run.py#L207)

2、**程序运行流程图**

   如下流程图展示整个流程中各个进程的状态转换。

   注意：流程图中左侧为调试进程，右侧为其他进程；图中分别标注“进入断点前”、

   “进入调试状态”和“解除阻塞后”的状态。

   ```text
                              ┌─────────────────────────────┐
                              │    所有进程到达断点处       │
                              └─────────────────────────────┘
                                           │
                                           ▼
                              ┌─────────────────────────────┐
                              │   调用 breakpoint_() 函数   │
                              └─────────────────────────────┘
                                           │
                                           ▼
                              ┌─────────────────────────────┐
                              │ 判断当前进程的角色：        │
                              │ (是否为调试进程？)          │
                              └─────────────────────────────┘
                                           │
                      ┌────────────────────┴─────────────────────────────┐
                      │                                                  │
                      ▼                                                  ▼
            ┌────────────────────────┐                       ┌────────────────────────┐
            │ 当前进程为调试进程     │                       │ 当前进程非调试进程      │
            │ (rank == RANK_TO_DEBUG)│                       │ (rank ≠ RANK_TO_DEBUG) │
            └────────────────────────┘                       └────────────────────────┘
                      │                                                  │
                      │                                                  │
            ┌──────────────────────────┐                    ┌────────────────────────┐
            │ 检查临时文件counter_file │                    │ 根据 non_block 参数区分 │
            │ 是否存在：               │                    │ 分支处理：              │
            │ － 不存在，则创建        │                    └─────────────┬──────────┘
            │    counter_file          │                                   │
            └──────────────────────────┘                                   │
                      │                                            ┌───────┴────────┐
                      │                                            │                │
                      ▼                                            ▼                ▼
            ┌───────────────────────┐                 ┌───────────────────┐   ┌────────────────────┐
            │ 打印创建日志          │                 │ 非调试进程：       │   │  非调试进程：      │
            └───────────────────────┘                 │ non_block=False   │   │  non_block=True    │
                      │                               │ － 进入等待状态    │   │  － 直接跳过等待   │
                      │                               │   a. 等待文件创建  │   └────────────────────┘
                      │                               │   b. 循环等待文件  │           │
                      │                               │      被删除        │           │
                      │                               └───────────────────┘            │
                      │                                          │                     │
                      ▼                                          │                     │
            ┌────────────────────────┐                           │                     │
            │ 调用 pdb.set_trace()   │                           │                     │
            │ 进入交互式调试模式     │                           │                     │
            └────────────────────────┘                           │                     │
                      │                                          │                     │
                      │                                          │                     │
                      │                                          │                     │
                      ▼                                          │                     │
            ┌───────────────────────────┐                        ▼                     │
            │   调试完成后调用 clear_() │              ┌───────────────────────┐       │
            │ （删除 counter_file，并   │ ─────────────│   （继续后续代码）    │        │
            │  自增 BREAKPOINT_COUNTER）│              └──────────────────────┘        │
            └───────────────────────────┘                        │                     │
                      │                                          │                     │
                      │                                          │                     │
           ┌──────────▼──────────────────┐                       └─────────────────────┘
           │   删除临时文件后：           │                                    │
           │ - 等待分支（non_block=False）│                                    │
           │   检测到文件删除，解除阻塞   │                                    │
           └──────────┬──────────────────┘                        ┌──────────────────────────┐
                      │                                           │    执行到下一个通信算子  │
           ┌──────────▼─────────────────┐                         │    等待调试进程通信      │
           │   执行c (continue)         │                         │                          │
           └──────────┬─────────────────┘                         └──────────────────────────┘
                      │                                                         │
                      │                                                         │
                      └──────────────────────────────┐──────────────────────────┘
                                                     ▼
                                      ┌─────────────────────────────┐
                                      │ 所有进程（调试进程、         │
                                      │  non_block=False等待分支、   │
                                      │  non_block=True直接分支）    │
                                      │ 均退出 breakpoint_()，       │
                                      │ 继续后续执行                 │
                                      └──────────────────────────────┘
   ```